<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="three.min.js"></script>
<script>
$(function() {
    var speed=.6;
    var xvel=0;
    var yvel=0;
    var zvel=0;
    var velC=.9;
    //var prevPos;
    var socket = io.connect('/3dgameHandler');
    var world=[];
    $(document).keydown(function(e) {
        var code = (e.keyCode ? e.keyCode : e.which);
        if (code===37) {//left
            //console.log("left!");
            //xpos-=speed;
            xvel-=speed;

        }
        else if (code===39) {//right
            //console.log("right!");
            //xpos+=speed;
            xvel+=speed;
        }
        else if (code===38) { //up
            zvel-=speed;
        }
        else if (code===40) { //down
            zvel+=speed;
        }
        else {
            return;
        }
        /*socket.emit('movement', {
            xpos:xpos
        });*/
    });
    var camera, scene, renderer;
    var geometry, material, cube;
    var width=window.innerWidth;
    var height=window.innerHeight;
var geometry_,material_,cube_;
    init();
    render();

    function init() {
        //z:forward(-)/backward(+), x:left/right, y:up/down
        //CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)
        camera = new THREE.PerspectiveCamera( 75, width / height, .1, 1000 );
        camera.position.z = 20;
        prevPos=camera.position;

        scene = new THREE.Scene();

        geometry = new THREE.CubeGeometry( 10, 10, 10 );
        //material = new THREE.MeshBasicMaterial( { color: 0xff0000} );
        texture = THREE.ImageUtils.loadTexture('sonic_sonicRunning.gif');
        material = new THREE.MeshBasicMaterial({map: texture});

        cube = new THREE.Mesh( geometry, material );
        cube.position.x=2;
        cube.position.y=0;
        cube.position.z=0;
        scene.add( cube );

        /*for (var i=-10;i<=10;i++)
        {
            for (var j=-10;j<=10;j++)
            {
                for (var k=-1; k<=1; k++)
                {
                    var geometry_ = new THREE.CubeGeometry( 1, 1, 1 );
                    var material_ = new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe:true} );
                    //var texture_ = THREE.ImageUtils.loadTexture('sonic_sonicRunning.gif');
                    //var material_ = new THREE.MeshBasicMaterial({map: texture_});

                    var cube_ = new THREE.Mesh( geometry_, material_ );
                    cube_.position.x=i;
                    cube_.position.y=j;
                    cube_.position.z=k;
                    scene.add( cube_ );
                }
            }
        }*/
        //floor:
        geometry_ = new THREE.CubeGeometry( 100, 1, 100 );
        material_ = new THREE.MeshBasicMaterial( { color: 0x964B00, wireframe:false} );

        cube_ = new THREE.Mesh( geometry_, material_ );
        cube_.position.x=0;
        cube_.position.y=-10;
        cube_.position.z=0;
        //scene.add( cube_ );

        //walls:
        geometry_ = new THREE.CubeGeometry( 1, 50, 100 );
        material_ = new THREE.MeshBasicMaterial( { color: 0x007700, wireframe:false} );

        cube_ = new THREE.Mesh( geometry_, material_ );
        cube_.position.x=-50;
        cube_.position.y=15;
        cube_.position.z=0;
        scene.add( cube_ );


        //renders grass on the ground
        geometry_ = new THREE.Geometry();
        //material = new THREE.MeshBasicMaterial( { color: 0xff0000} );
        texture_both = THREE.ImageUtils.loadTexture('textures/grass_dirt.png');
        texture_grass= THREE.ImageUtils.loadTexture('textures/grass.png');
        texture_dirt= THREE.ImageUtils.loadTexture('textures/dirt.png');
        
        material_ = new THREE.MeshFaceMaterial([
            new THREE.MeshBasicMaterial({ //bottom or back
            map: texture_grass
        }), new THREE.MeshBasicMaterial({ //left
            map: texture_dirt
        }), new THREE.MeshBasicMaterial({ //top
            map: texture_grass
        }), new THREE.MeshBasicMaterial({
            map: texture_both
        }), new THREE.MeshBasicMaterial({
            map: texture_both
        }), new THREE.MeshBasicMaterial({
            map: texture_both
        })]);

        //material_ = new THREE.MeshBasicMaterial({map: texture_grass});
        
        for (var i=-50;i<=50;i++) {
            for (var j=-50;j<=50;j++) {        
                cube_ = new THREE.Mesh( new THREE.CubeGeometry( 1, 1, 1 ), material_ );
                cube_.position.x=i;
                cube_.position.y=-10;
                cube_.position.z=j;
                //scene.add( cube_ );
                THREE.GeometryUtils.merge(geometry_,cube_);
            }
        }
        mesh_ = new THREE.Mesh( geometry_, material_ );
        scene.add(mesh_);


        renderer = new THREE.WebGLRenderer();
        //THREE.WebGLRenderer() THREE.CanvasRenderer()
        renderer.setSize( width, height );
        //renderer.setSize(720,540);
        renderer.setClearColorHex( 0xfffeef, 1 );

        document.body.appendChild( renderer.domElement );

    }
    function render() {

        // requestAnimationFrame stops when going to a diff. tab
        requestAnimationFrame( render );

        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
        cube.rotation.z += 0.01;
        camera.position.x+=xvel;
        camera.position.y+=yvel;
        camera.position.z+=zvel;
        xvel*=velC;
        yvel*=velC;
        zvel*=velC;

        renderer.render( scene, camera );

        if ((Math.round(prevPos.x*100)!=Math.round(camera.position.x*100)) ||
            (Math.round(prevPos.y*100)!=Math.round(camera.position.y*100)) ||
            (Math.round(prevPos.z*100)!=Math.round(camera.position.z*100))
            ) {
            socket.emit('playerPos',{
                x:camera.position.x,
                y:camera.position.y,
                z:camera.position.z
                });
        }
        //prevPos=camera.position;

    }
    socket.on('playerPos',function(data) {
        cube.position.x=data.x;
        cube.position.y=data.y;
        cube.position.z=data.z;
    });
    function genChunk() {

    }
});
</script>
<style>
canvas {
    width:100%;
    height:100%;
}
body {
    margin:0;
    padding:0;
}
</style>